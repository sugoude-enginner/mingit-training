# mingit-training

最低限のGitを段階的に作ることでGitの理解を深めることを目標に、その仕様とチュートリアルをまとめていくリポジトリです。

## VCS（Version Control System)としての最小要件

「あるバージョンの状態を参照できること」がVCSとしての最小要件になります。

バージョン管理をする目的は、バージョンを付与した時の状態（例えば、あるバージョンのソースコード）を再現することだからです。

Gitの場合、バージョンに対応する概念として”コミット”があります。

### コミットとは？

コミットはRPGのセーブデータのようなものです。

勇者をレベル２にしたときのセーブデータのように、ある状態のソースをコミットとして保存することができるのです。

そして、特定のセーブデータを起動するように、特定のコミットをチェックアウトすることができます。

では、勇者をレベル２にしたときのセーブデータから初めて、勇者をレベル３にあげたセーブデータを保存したとします。

一般的なRPGとは違い、Gitではセーブのたびに全てのデータがまるごと保存されるわけではありません。

変更されたファイルだけを新たに保存し、バージョン管理対象のすべてのファイルへのリンク（スナップショットといいます）を保存します。

例えば、AとBというファイルをバージョン管理の対象としたあとに、Bのみを変更したとします。

その時、最初のスナップショットは

- Aへのリンク
- 変更前のBへのリンク

次のスナップショットには

- Aへのリンク
- 変更後のBへのリンク

が保存されます。

そして、コミットにはそれぞれのスナップショットへの参照が保存されるのです。

RPGのようにまるごとデータを保存していたら、容量がどんどん膨らんでいってしまいます。

Gitでは差分ファイルの容量と、リンクのみを保存したスナップショット、そしてコミットのみが追加されるだけなので、非常に高速かつ省エネルギーなのです。

#### コミットグラフ

コミットには前述したスナップショットへの参照に加えて、前回のコミットを特定する情報も含まれます。

あるコミットから見た前回のコミットのことを”親コミット”と言います。

２つのコミットの関係は、

```
（A）←（B）
```

というように表されます。（Aが親、Bが子）

時系列を考えれば矢印が逆なのですが、子は親コミットへの参照を持っているので、こういう向きになっていると考えられます。（そもそも矢印を使ってなかったり、時系列の矢印になっていることもよくあるので、気にしなくても良さそう）

RPGの例えだと、レベル２の勇者のセーブデータ（A)　← レベル３の勇者のセーブデータ（B)　というような関係を表しているのですが、例えばレベル２の勇者のセーブデータから始めて「レベル２の勇者とレベル２の魔法使いのセーブデータ」を作る場合もあると思います。

Gitのコミットにおいても同様な構造が表現できます。

```
（A）←（B）
　　 ↖︎（C）
```

「Aから始めてB」と「Aから始めてC」という２つの時系列があるわけで、このような状態は（A)のコミットから分岐していると言えます。

この状態だと、横向きですが「ツリー」状なのでコミットツリーと呼ばれることがあります。

しかし、実はBとCを合流した新しいコミットDを作ることもできます。

RPGで例えるなら、

- レベル３の勇者のセーブデータ（B)
- レベル２の勇者とレベル２の魔法使いのセーブデータ（C)

を合成して、

- レベル３の勇者とレベル２の魔法使いのセーブデータ（D)

という全く新しいセーブデータを作成してしまうことができます。

その結果、

```
（A）←（B）←（D）
　　 ↖︎（C）↙︎
```

という構造ができます。この時にDの親はBとCの２つになります。

また、AはBとCの共通の祖先という言い方もします。

こうすると、図はツリーではなくグラフになります。

なのでコミットグラフと呼べますが、簡易的にコミットツリーと呼ばれていることも多いです。

Gitを理解する上で、現在作業しているコミット周辺のグラフの形が想像できないと、余計な落とし穴にハマってしまうことになります。

自分がしている操作がどのようにコミットグラフに影響を与えるかを考られることが、Gitをシンプルに理解することへの近道なのです。

そして、Gitそのものを作成する上でも各操作を実装する際、どのようにコミットグラフを書き換えれば良いかを常に考えることになります。

### VCSとしての最低限の操作

ここまでの話を踏まえると、

- コミットの作成　→ `git commit`
- コミットの合流　→ `git merge`
- あるコミットの参照　→　`git checkout`

ができれば、最低限のVCSとしての機能が果たせそうです。

また、大抵の開発プロジェクトにおいては、プロジェクトのソースを格納するフォルダを専用で作ることから、Gitもそれに倣い「フォルダを指定し、そのフォルダ内を管理の対象とする」仕組みになっています。

なので、フォルダを指定する操作も必要になります。

- リポジトリの作成（どのフォルダの中を対象とするか）→ `git init`

です。

Gitが管理するソースとコミットグラフのデータなどのGit用のデータを含めて”リポジトリ”と呼びます。

`git init`を実行したフォルダ内がバージョン管理の対象となります。

上記であげた４つの操作を実装していくことが最小限のGitを作っていく上でのステージ１となるでしょう。
